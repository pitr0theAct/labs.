

#include <iostream>
#include <string>
#include <vector>

// Функция для вычисления префикс-функции
//(Находим вектор мксимально совпавших префиксов и суффиксов в шаблоне)
std::vector<int> KMP(const std::string& pattern) 
{
    std::vector<int> arr(pattern.size(), 0);//создание вектора arr, размер которого равен размеру шаблона, заполненного нулями.
    int i = 1, j = 0;//Определяем индесы i и j (j-префикс, i-суффикс)
    
    //Проходим по всему шаблону
    while (i < pattern.size()) 
    {
        
        //Если префикс и суффикс совпали 
        if (pattern[j] == pattern[i]) 
        {
            arr[i] = j + 1;//Записываем в вектор длинну совпавшей части 
            i++; j++;//Увиличиваем i и j 
        }
        
        //Если префикс и суффикс не совпали
        else
        {
            //И если j индекс равен 0
            if (j == 0)
            {
                arr[i] = 0;//Значение в масиве меняем на ноль 
                i++;//увиличиваем i
            }
            
            //Если j индекс не равен 0 
            else
            {
                j = arr[j - 1];// Обновляем j значением из вектора arr на позиции j - 1
            }
        }
    }
    return arr;// Возвращаем вектор префикс-функции	
}

// Функция для поиска подстроки в тексте с использованием алгоритма Кнута-Морриса-Пратта
void searchPattern(const std::string& text, const std::string& pattern) 
{
    int n = text.size();// Получаем длину текста
    int m = pattern.size();// Получаем длину шаблона
    std::vector<int> p = KMP(pattern);// Получаем вектор префикс-функции для шаблона
    int i = 0, j = 0, check = 0;// Инициализируем переменные i, j и check
    
    // Пока не достигнут конец текста
    while (i < n) 
    {
        // Если символ на позиции i в тексте совпадает с символом на позиции j в шаблоне
        if (text[i] == pattern[j]) 
        {
            i++; j++;// Увеличиваем значения i и j
            if (j == m) // Если j достигло конца шаблона
            {
                check = 1;// Устанавливаем флаг check в 1
                std::cout << "Pattern found at index " << i - m << std::endl;// Выводим информацию о найденном шаблоне
            }
        }
        
        // Если символ на позиции i в тексте не совпадает с символом на позиции j в шаблоне
        else 
        {
            if (j > 0)//Если j больше 0
            {
                j = p[j - 1];// Обновляем j значением из вектора p на позиции j - 1
            }
            
            //в противном случае 
            else 
            {
                i++;// Увеличиваем i
            }
        }
        
        // Если прошли весь текст и шаблон не был найден
        if (i == n && !check)
        {
            std::cout << "There is no pattern in the text " << std::endl;// Выводим информацию о том, что шаблон не найден
        }
    }

}

int main() 
{
    std::string text = " abcabca abacbab abcabcabc";
    std::string pattern = "abcabc";
    searchPattern(text, pattern);
    return 0;
}

